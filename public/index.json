[
{
	"uri": "/aulas/",
	"title": "Conteúdo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/aulas/0_eletrofisiologia/",
	"title": "Introdução a eletrofisiologia",
	"tags": [],
	"description": "",
	"content": "HIstória A história da eletrofisiologia começa na tentativa de identificar telepatia em humanos.\n 1929 - Hans Berger queria medir telepatia em humanos pela primeira vez: Como um soldado no exército alemão na primeira década de 1900, Hans Berger caiu de seu cavalo em frente de um carro de artilharia e quase foi atropelado. Quando ele voltou para o quartel, havia um telegrama de seu pai dizendo que sua irmã teve a “sensação” de que ele tinha sido ferido. Com essa motivação, Berger quis explorar manifestações físicas dessas transmissões psíquicas  1935 - Hallowell e Pauline Davis obtêm os primeiros registros de ERPs (potencial evocado). 1964 - Gray Walter reporta o primeiro componente cognitivo de ERP - era moderna da técnica 1964 - Sutton, Braren, Zubin e John descobrem o P300 1960: ERPlogy: estudo dos componentes do ERP 1980: Ressurgimento devido à popularização dos computadores   Eletroencefalograma EEG hoje Para aquisição de dados EEG, usualmente se utiliza equipamento de 128 eletrodos de posições delimitadas para medir atividade na superfície do córtex (medição de potencial elétrico).\nOs sinais elétricos detectados no couro cabeludo que têm origem não-cerebral são chamados de artefatos. A amplitude dos artefatos pode ser significativamente maior que a amplitude dos sinais corticais de interesse, o que facilita identificação das diferenças desses padrões.\nAlterações momentâneas na impedância de um determinado eletrodo pode causar “spikes”.\nNos casos do sinais de Eletroencefalografia (EEG), temos o ruído da rede elétrica que no Brasil é 60 Hz. Muitos laboratórios utilizam gaiola de Faraday para amenizar o problema (isolamento da energia), mas ainda assim a filtragem é necessária para garantir a qualidade do sinal coletado.\nAlém desses existem outros artefatos como ondas de baixas frequências devido a temperatura da cabeça do indivíduo. Deste modo, é extremamente importante aplicação de filtros nestes sinais para remoção de tais artefatos antes de qualquer outra análise.\nDas análises mais comuns realizadas com EEG, estão: ERP - Potenciais relacionados ao evento e Análise Espectral.\nPotencial relacionado ao evento - ERP O potencial evocado ou resposta evocada é um potencial elétrico registrado do sistema nervoso de um humano ou outro animal seguido da apresentação de um estímulo, distinto dos potenciais espontâneos detectados por eletroencefalografia (EEG).\n Análise espectral Com potenciais induzidos, com mudanças no tempo (eixo x), quando não há sincronia no tempo no experimento entre os voluntários, é utilizada a análise espectral.\nA análise de Fourier consiste na separação do sinal em vários componentes senoidais (soma de senos). As senóides são a base que levam qualquer ponto no espaço, nesse caso, é possível transportar qualquer sinal (finito).\nSNC A transformada de Fourier pega os sinais em várias frequências distintas e devolve as frequências fundamentais.\n Wavelets Análises cuidadosas dos registros do eletroencefalograma (EEG) podem fornecer informações valiosas sobre esse distúrbio disseminado do cérebro. A Wavelet é uma ferramenta de análise de tempo e frequência eficaz para a análise de sinais transientes. Suas propriedades de extração e representação de características podem ser usadas para analisar vários eventos transitórios em sinais biológicos.\n    "
},
{
	"uri": "/aulas/1_intror/",
	"title": "Introdução ao R",
	"tags": [],
	"description": "",
	"content": "Introdução ao R - comandos O R é um software importante para análise de dados estatísticos. Apesar de não ter uma interface gráfica , a usabilidade é melhor para personificação das análises e permite mais opções para visualização e análise de dados.\nVetor e matrizes no R: Para armazenar um valor a uma variável, simplesmente usamos:\nx = 3.7 O vetor é uma estrutura de dados básica do R, que permite armazenar um conjunto de valores numéricos ou de caractere sob um mesmo tipo.\nx = c(1, 2, 3, 4) x ## [1] 1 2 3 4 Para criar um vetor com repetidos valores, por exemplo uma repetição de zeros, utiliza-se:\nx = array(0, 100) x ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [36] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [71] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Para criar uma matriz, utiliza-se uma estrutura similar.\nx = matrix(1, 2, 2) x ## [,1] [,2] ## [1,] 1 1 ## [2,] 1 1 Atribuindo algum valor (1000) ao intervalo, no caso primeira linha:\nx[1,]=1000 # Saída da matriz inteira com 1000 na primeira linha e 1 no resto: x ## [,1] [,2] ## [1,] 1000 1000 ## [2,] 1 1 Caso queira exibir uma única linha ou coluna, basta digitar o comando com a linha ou coluna desejada:\n# Coluna x[,2] ## [1] 1000 1 #Linha: x[2,] ## [1] 1 1  Listas no R: Listas são objetos que podem armazenar objetos de dados de tipos diferentes. É possível incluir data.frames, arrays, matrizes, vetores, fatores e mesmo listas em uma lista.\nlist=list() list$nome = \u0026quot;joao\u0026quot; list$idade = 40 list$vetor=c(1,2,3) list$nome ## [1] \u0026quot;joao\u0026quot; # Saída: list ## $nome ## [1] \u0026quot;joao\u0026quot; ## ## $idade ## [1] 40 ## ## $vetor ## [1] 1 2 3  Loops R: Para realizar uma repetição com variável de controle, o comando for() incrementa um índice dentro de uma sequência de valores.\nfor(i in 1:10){ print (i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Para reaizar uma repetição pré-testada, o teste para sair do laço de repetição é realizado antes de entrar no laço, e para isso utilizamos a função while():\ni=1 while(i\u0026lt;=10){ print (i) i=i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Ou outro exemplo:\ni=1 while(i\u0026lt;=10){ print (i) if (i\u0026lt;=5) { print(\u0026quot;menor ou igual a 5\u0026quot;) } else{ print(\u0026quot;maior que 5\u0026quot;) } i=i+1 } ## [1] 1 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 2 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 3 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 4 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 5 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 6 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 7 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 8 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 9 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 10 ## [1] \u0026quot;maior que 5\u0026quot; No R, o índice i for imutável, recomenda-se utilizar o “for” como opção de repetição.\n Outras funções úteis no R: A Estatística Descritiva está diretamente ligada à organização e descrição dos dados. É utilizada para sumarizar como as observações se distribuem e onde estão posicionadas (ex.: medidas de tendência central e dispersão) e como se apresentam em termos de associação. Os conceitos e métodos descritivos são ponto de partida da análise exploratória de dados, passo fundamental para análises estatísticas mais avançadas.\nConsiderando a matriz criada x,\nx ## [,1] [,2] ## [1,] 1000 1000 ## [2,] 1 1 temos as seguintes funções para estatística descritiva:\n# Média: mean(x) ## [1] 500.5 # Desvio padrão sd(x) ## [1] 576.7729 # Distribuição normal: rnorm(x) ## [1] -0.2941549 -0.5695707 -1.1018875 1.4181125 # Boxplot: boxplot(x)   Leitura de dados de ECG A primeira vista, pode parecer contraintuitivo que num curso de Processamento de Sinais Neurais contenha análise de dados de Eletrocardiograma (ECG). Dentre os parâmetros que podem ser aferidos a partir do ECG é a frequência cardíaca (número de batimentos do coração que acontecem a cada minuto - bpm). A freqüência cardíaca é capaz de indicar uma ativação geral do sistema nervoso autônomo, responsável por controlar nossas reações corporais involuntárias. Ao expor uma pessoa em situações de maior demanda energética, o coração bate mais forte e mais rápido.\nO uso do ECG fornece dados informativos acerca dos processos psicofisiológicos em diversas situações, sendo altamente aplicável em estudos que investigam as respostas comportamentais como por exemplo de consumidores ou outros entrevistados.\nLeitura de dados de ECG: Na aula o professor disponibilizou dados de um arquivo em que ele coletou dados de ECG de si mesmo (a partir de um arduino). O arquivo contém uma única coluna que é o valor em mV coletado com o instrumento:\ndados = read.table(\u0026quot;ecg.txt\u0026quot;, header = FALSE) Para visualizar os dados da forma de série temporal, utiliza-se a função ts.plot(). Algumas versões do R Studio contém um problema para visualização dos dados, então utiliza-se a seguinte gambiarra recomendada pelo Stackoverflow:\n# Pra não dar erro \u0026quot;figure margins too large\u0026quot; no ts.plot: graphics.off() par(\u0026quot;mar\u0026quot;) ## [1] 5.1 4.1 4.1 2.1 par(mar=c(1,1,1,1)) Após implementar essas linhas, na sequência, visualizamos os dados com a função:\n# Plotando gráfico de linha - ECG ts.plot(dados) Um histograma pode ajudar a melhorar a visualização da amplitude do sinal:\nhist(dados$V1) Para fins de referência, consideremos como picos de batimentos os valores com resultados acima de 685mV, então destacaríamos os maiores:\n# Para percorrer todas as casas dos dados, detectando os picos: picos=array(0, nrow(dados)) for(i in 1:960){ if(dados$V1[i]\u0026gt;685){ picos[i]=1 } } # Unindo no plot as colunas de dados e picos ts.plot(cbind(dados$V1, picos)) # Como pode ver, ficou zoado, então ajustamos a escala e adicionamos cores para que se possa visualizar os dados: # cores: col 2 = preto e 1 vermelho ts.plot(cbind(dados$V1, picos+684), col=c(2,1)) O ajuste ainda não ficou muito claro. Toda vez que encontrar um pico, os valores conseguintes referem-se ao mesmo pico, ou seja, devemos limpar os dados (retirada de picos contínuos adjacentes). Neste caso, escolhemos ignorar os picos dos 10 dados seguintes ao primeiro pico.\nNota: Para percorrer o vetor completo, basta percorrer o código até os 10 últimos (critério de parada) dados. Os demais picos seriam ignorados de qualquer forma e poderia reproduzir erro no vetor.\nDessa forma, teríamos:\nfor(i in 1:(nrow(dados)-10) ){ if(picos[i]==1){ picos[(i+1):(i+10)]=0 } } ts.plot(cbind(dados$V1,picos+684),col=c(2,1))   "
},
{
	"uri": "/aulas/2_filtro_sinais/",
	"title": "Filtros de sinais",
	"tags": [],
	"description": "",
	"content": "O processo de filtragem de sinais permite a caracterização dos sinais a partir de suas características. Por exemplo, aplicado ao som as frequências mais altas representam os sons mais agudos, enquanto que as frequências mais baixas representam os sons mais graves.\nOs artefatos em EEG caracterizam de ondas não cerebrais, denominadas por ruídos, como por exemplo a frequência da rede elétrica de 60hz, ondas de baixas frequências devido ao calor no couro cabeludo do indivíduo. Deste modo, é extremamente importante aplicação de filtros nestes sinais para remoção de tais artefatos antes de qualquer outra análise.\nPara tratar esses sinais, seja, frequências altas, baixas ou algum determinado intervalo, definimos um filtro passa baixa a partir da subtração do sinal original pela média aritmética dos pontos ao redor. Alguns conceitos importantes para a construção dos filtros:\n Frequência de amostragem: Trata-se da frequência de sinais observados em um intervalo de tempo (medidos em hertz = 1/s).  Ex: No EEG utiliza-se uma frequência de 250 por segundo. Com FNIRS, utiliza-se em torno de 7 frames por segundo. Na ressonância magnética funcional (fMRI), temos 1 imagem a cada 2 segundos. Logo, a frequência de amostragem é 1/2 = 0.5Hz Observação: A frequência = 1/período da observação  Frequência de Nyquist: Corresponde à metade da frequência da taxa amostragem. Pelo teorema de Nyquist, para prevenir o aliasing (sobreposição de sinais) deve-se:aumentar da taxa de amostragem até duas vezes da maior frequência do sinal. Se o sinal é limitado no tempo a frequência de amostragem deve ser tão alta quanto se conseguir, pois em frequência o sinal se espalha por todo o espectro sendo não limitado; com isso deve-se remover ou filtrar as frequências acima da frequência mais alta desejada evitando a formação do aliasing  Note: A frequência de Nyquist vale para qualquer modalidade de técnica de neuroiumagem (fMRI,EEG,fNIRS…).   O filtro permite a passagem o sinal de parte dos dados e impede a retirada de outros. São os filtros:\n Passa-alta (High pass): Deixa passar as altas frequências (maior importância pra alta frequência e baixa importáncia para baixa frequência.\n Passa-baixa (Low pass): Deixa passar as baixas frequências e dá pouca importância às altas frequências.\n Passa-banda (band pass): O sinal resultante após o filtro possui apenas a banda de frequência utilizada no filtro.\n  Implementação de filtros em R e carregando dados: No R faremos primeiro o desenho do filtro: ou seja definir qual o tipo de frequências vamos passar, para isso usaremos o comando “butter” no pacote signal.\nCaso não tenha o pacote, utilize os comandos:\nInstalando pacote de sinais no R: * install.packages(“signal”)\ne no código chamar a blbioteca\nrequire(signal) O exercício da aula mostra a leitura de um banco de dados de sinais de EEG.\nPara isso, será necessário realizar a leitura dos dados:\nsinais=read.table(\u0026quot;oddball250hz.txt\u0026quot;,header=FALSE) ver também a verificação dos dados:\ndim(sinais) ## [1] 45461 33 Olhando o arquivo, ele é composto por 45461 linhas e 33 colunas (essas referentes aos 32 canais e uma última coluna de zeros).\nPara verificar os dados do arquivo em um plot:\n# Plot da série temporal: #gambiarra para o ts.plot funcionar no R Studio: graphics.off() par(\u0026quot;mar\u0026quot;) ## [1] 5.1 4.1 4.1 2.1 par(mar=c(1,1,1,1)) e o plot:\n# Plotando gráfico de linha ts.plot(sinais) A taxa de amostragem é a frequência em que a leitura ocorre: * HZ=1/INTERVALO, onde 1hz = 1/s\n# Suponha que o sinal foi adquirido sob uma taxa de amostragem de 250Hz: HZ= 250 Dessa forma, analisamos o sinal com base nessa amostragem, para todas as linhas, para o canal 5, com o plot do tipo l (linha):\n#Fazer gráfico com frescura: # plot(1:nrow(sinais), sinais[,5],type=\u0026quot;l\u0026quot;) # mas preciso considerar a frequência convertendo pra segundos: plot((1:nrow(sinais))/HZ, sinais[,5], type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab= \u0026quot;sinal uV\u0026quot;)  Utilizando a função do filtro (butter): Primeiramente se define qual o tipo de frequências vamos passar, para isso usaremos o comando “butter”. A função butter possui a seguinte síntaxe: * butter (n = ordem do filtro, w = cutoff, tipo = tipo de filtro) onde, + ordem do filtro = controla o decaimento da curva de ajuste do filtro, geralmente se usa 3 ou 5. + cutoff = frequências que se queira cortar (é um número de 0 a 1, neste caso é preciso fazer uma regra de 3; 0 = 1 e 1= frequências de Nyquist) + type = tipo de filtro (low/passa-baixa, high/passa-alta ou band-pass/passa banda)\nAplicando passa-baixa em 30Hz:\nFILTRO = butter(n=5, W =30/(HZ/2), type = \u0026quot;low\u0026quot;) # Gráfico do desenho do filtro: freqz(FILTRO) Após ter o filtro desenhado, aplica-lo sobre os dados do canal (neste caso seria o canal 5, como exemplo, mas poderia ser qlq um). Ao aplicar o filtro de forma direta teríamos ainda um problema:\nfiltrado_teste = filter(FILTRO, sinais[,5]) # bug de início do sinal, com valor muito alto. Neste caso “bugado” teríamos o seguinte retorno:\n#Fazer o grafico com os 2 sinais plot((1:nrow(sinais))/HZ, sinais[,5],type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) #Acrescentar linha com o sinal filtrado lines((1:nrow(sinais))/HZ, filtrado_teste, col=2) Para isso resolve-se tirando a média do sinal:\ny = sinais[,5] - mean(sinais[,5]) # e novamente aplicando o filtro no sinal: filtrado = filter(FILTRO, y) obtendo então o sinal filtrado:\n#Acrescentar linha com o sinal filtrado plot((1:nrow(sinais))/HZ,y,type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) lines((1:nrow(sinais))/HZ, filtrado, col=2) Dessa forma é possível aplicar outros filtros, alterando o tipo na função butter e aplicando aos sinais de todos os canais na função filter. Dica de exercício: Tente executar para outros canais ou então ajustando o filtro para outras frequências ou determinados intervalos de frequência.\nUm exemplo comum é a aplicação de um filtro que processe dados de um determinado intervalo (por exemplo, como a rede elétrica é 60hz mas há oscilações, processa-se sinal entre 59-61hz). Neste caso, queremos um passa-banda para deixar apenas entre as frequências de 1-40 hz:\n# butter (n = ordem do filtro, w = cutoff, tipo = tipo de filtro) # - n = Ordem do filtro = controla o decaimento da curva de ajuste do filtro, # geralmente se usa 3 ou 5. # -type = tipo de filtro (low/passa-baixa, high/passa-alta ou band-pass/passa banda) FILTRO = butter(n=5, W =c(1,40)/(HZ/2), type = \u0026quot;pass\u0026quot;) freqz(FILTRO) Quero aplicar este filtro em todas as colunas da matriz de sinais, realizando a retirada da média para tirar os outliers antes do filtro. O sinal bruto permanece sem o ajuste das médias, então para executar em todos os canais, é importante que y esteja nas interações:\nfsinais = matrix(0, nrow(sinais), ncol(sinais)) for (canal in 1:32) { y = sinais[,canal] - mean(sinais[,canal]) fsinais[,canal]=filter(FILTRO,y) } Para verificar o sinal bruto e filtrado de cada canal, tirando a média (o exemplo contempla o canal 1):\n#Checar o sinal bruto e filtrado plot((1:nrow(sinais))/HZ,sinais[,1]-mean(sinais[,1]),type=\u0026quot;l\u0026quot;,xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) lines((1:nrow(sinais))/HZ,fsinais[,1],col=2) Observações sobre a implementação de filtros: 1. Adicionar a taxa de amostragem atribuindo um valor para HZ.\n Passa-baixa em 30hz: ** FILTRO = butter(n=5, W = 30/(HZ/2), type = “low”)\n Passa-banda para deixar apenas entre as frequências de 1-40 hz: ** FILTRO = butter(n=5, W = c(1,40)/(HZ/2), type = “pass”)\n Passa-alta para frequências acima de 0.2hz: ** FILTRO = butter(n=5, W = 0.2/(HZ/2), type = “high”)\n   "
},
{
	"uri": "/aulas/3_potenciaisevocados/",
	"title": "Potenciais Evocados",
	"tags": [],
	"description": "",
	"content": "Potencial relacionado a evento (ERP, do inglês Event-Related Potential), é uma resposta direta do cérebro a um específico estímulo cognitivo, sensorial, ou motor. ERPs são obtidos por promediação (no tempo).\nOs componentes são designados por uma letra (N - negative / P - positive), seguido de um número que pode indicar tanto a latência em ms como a posição da componente na forma de onda.\nAlguns exemplos de ERPs e suas devidas funções:\n P1 (ou P100) concentraram-se em observar as variações deste potencial durante estimulação visual. Pesquisas posteriores sobre o P1 começaram a olhar para alterações do P1 em relação à atenção seletiva. Sua amplitude máxima é observada sobre o lobo occipital, contralateral ao campo visual no qual o estímulo é apresentado. O N1 (também chamado de N100) é o primeiro componente negativo contínuo e o seu pico é normalmente observado entre 80 e 160 ms após o aparecimento do estímulo. Forte sobre a região fronto-central do couro cabeludo. Embora a maioria das pesquisas se concentra em estímulos auditivos, o N100 também ocorre para estimulação visual, olfativa e táctil. O N100 é pré-atencional e diretamente envolvido na percepção porque sua amplitude é fortemente dependente de coisas como o tempo de subida de um som, sua intensidade, o intervalo entre estímulos e a frequência comparativa, ou seja, sua amplitude aumenta em proporção a quanto um som difere em frequência de um som precedente. O P2 (P200) potencial positivo que ocorre cerca de 200 milissegundos frequentemente distribuído em torno das áreas centro-frontal e parieto-occipital do couro cabeludo. Sua associação ainda está em desenvolvimento pois há um grande e diversificado número de tarefas cognitivas associadas a essa componente. N2, ou N200, encontrada principalmente na parte anterior do couro cabeludo em resposta a estímulos auditivos inesperados ou raros,com ou sem atenção, é referido como a negatividade de incompatibilidade (mismatch negativity – MMN). Mais genericamente, foi descrito em tarefas que refletem a identificação de estímulos, deslocamentos atencionais, inibição de respostas motoras, superação de respostas estereotípicas ou monitoramento de conflitos, manutenção de informações de contexto, seleção de respostas, timing, e detecção de novidade (novelty) ou incompatibilidade (mismatch). P3 (P300) tipicamente medido mais fortemente pelos eletrodos que cobrem o lobo parietal, está suscitado no processo de tomada de decisão. Mais especificamente, considera-se que o P300 reflete processos envolvidos na avaliação ou categorização do estímulo. Geralmente é provocado usando o paradigma oddball, em que eventos alvo (ou “raro”) de baixa probabilidade são misturados com itens não-alvo (ou “padrão”) de alta probabilidade  Outros componentes de ERP mais tardios, como por exemplo o N400 e o P600 são muito usados na área de neurociência da linguagem. Os componentes mais pesquisados na literatura ainda são o N1 e o P3.\n# Leitura dos dados sinais=read.table(\u0026quot;oddball250hz.txt\u0026quot;,header=FALSE) Para continuar a leitura dos filtros, deve-se realizar a leitura dos dados de canais também disponibilizados:\n# Leitura dos canais de EEG: nomes=scan(\u0026quot;nomecanais.txt\u0026quot;, what = \u0026quot;string\u0026quot;) Ao analisar o arquivo dos sinais, é possível verificar que a coluna 33 não se trata de sinais cerebrais, mas sim, a referência dos triggers (marcações do experimento). Dessa forma, realiza-se a leitura dos sinais e dos triggers, armazenando em matrizes separadas:\n# Separar o trigger dos sinais # Jogo fora o sinal 33 porque não é dado cerrebral trigger = sinais[,33] sinais= sinais[,1:32] Analisando a matriz trigger com o comando table, é possível verificar os tipos de eventos existentes no experimento (eventos raros marcados por 10 e frequentes marcados por 11):\n# Lendo o conteúdo do trigger: # esse comendo mostra o número de observações de cada tipo table(trigger) ## trigger ## 0 10 11 ## 45422 10 29 Olhando o conteúdo do trigger:\n# Conteúdo do vetor do trigger: ts.plot(trigger) Para identificação dos potenciais evocados, precisamos ainda definir os canais (a matriz sinais já exclui a coluna de trigger do arquivo) e pontos no tempo (número de linhas do arquivo):\n# Número de canais: Ncanais =ncol(sinais) # Número de pontos no tempo: T=nrow(sinais) Filtrando os sinais de todos os canais:\nFILTRO = butter(n=5, W =c(1,40)/(HZ/2), type = \u0026quot;pass\u0026quot;) freqz(FILTRO) fsinais = matrix(0, nrow(sinais), ncol(sinais)) for (canal in 1:32) { y = sinais[,canal] - mean(sinais[,canal]) fsinais[,canal]=filter(FILTRO,y) } plot((1:nrow(sinais))/HZ,sinais[,1]-mean(sinais[,1]),type=\u0026quot;l\u0026quot;,xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) lines((1:nrow(sinais))/HZ,fsinais[,1],col=2) Considerando a taxa de amostragem de 250hz, quero calcular uma determinada janela no intervalo 100ms dado um canal:\n# Se a taxa de amostragem é HZ= 250, quero definir as janelas pré e pós estímulos, ou seja 1s = 250hz, 100ms = 250hz/10: JANELApos=HZ #janela de 1 segundo JANELApre=HZ/10 #janela de 100 milisegundos O comando which ajuda a separar os estímulos:\n#Descobrir quais as caselas do vetor trigger se referem ao estimulo freq e raro TiRaro= which(trigger==10) #estimulo raro TiFreq= which(trigger==11) #estimulo frequente Armazenando os potenciais evocados do estímulo raro:\n# Matriz que guarda os potenciais evocados medios do estimulo raro ti=1000 PERaro=matrix(0,length((ti-JANELApre):(ti+JANELApos)), Ncanais) # for pra cada canal for(canal in 1:Ncanais){ for(ti in TiRaro){ BASELINE=mean(fsinais[(ti-JANELApre):ti,canal]) y=fsinais[(ti-JANELApre):(ti+JANELApos),canal]-BASELINE PERaro[,canal]= PERaro[,canal]+y/length(TiRaro) } } Por exemplo, olhando a legenda no arquivo, nomedoscanais, vemos que o canal Fz se refere ao canal 5. Desa forma, o gráfico:\n#Fazer o grafico do potencial evocal no canal Fz. coluna 5 # estimulo acontece em milisegundos (ms) por isso converto com a taxa de # amostragem plot((1:nrow(PERaro))/HZ*1000-100, PERaro[,5],type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(ms)\u0026quot;, ylab=\u0026quot;Sinal(uv)\u0026quot;) abline(v=0,lty=3) Agora armazenando os potenciais evocados do estímulo frequente:\n#Matriz que guarda os potenciais evocados medios de todos os canais PEFreq=matrix(0,length((ti-JANELApre):(ti+JANELApos)), Ncanais) #Calculo para todos os canais for(canal in 1:Ncanais){ for(ti in TiFreq){ BASELINE=mean(fsinais[(ti-JANELApre):ti, canal]) y=fsinais[(ti-JANELApre):(ti+JANELApos), canal] -BASELINE PEFreq[,canal] = PEFreq[,canal]+ y/length(TiFreq) } #fecha o for do ti } #fecha o for do canal #Fazer o grafico do potencial evocal no canal Fz. coluna 5 plot((1:nrow(PEFreq))/HZ*1000-100, PEFreq[,5], type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(ms)\u0026quot;, ylab=\u0026quot;Sinal(uv)\u0026quot;) abline(v=0,lty=3) Para conseguir fazer uma comparação entre os potenciais evocados, adicionamos os dois gráficos conjuntamente. Sendo nas cores Preta para estímulo frequente e vermelho para estímulo raro.\n#Fazer o grafico do potencial evocal no canal Fz. coluna 5 #Do estimulo raro e frequente no mesmo grafico plot((1:nrow(PEFreq))/HZ*1000-100, PEFreq[,5],type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(ms)\u0026quot;,ylab=\u0026quot;Sinal(uv)\u0026quot;,ylim=c(-7,7)) lines((1:nrow(PERaro))/HZ*1000-100, PERaro[,5],col=2) abline(v=0,lty=3) Obs: os valores arbitrários em ylim foram ajustes manuais para alinhar a visualização superior e inferior das linhas, ao fazer o plot de ambas poderia ter feito melhor, mas sabe como a vida é…\nAnalisando esse tipo de gráfico, é possível ver diferença entre os estímulos. Claro que para ter significância estatística precisaria de uma avaliação mais profunda para poder confirmar a real existência dessa diferença.\nFazer o plot da diferenca do PE raro e frequente no canal Pz, coluna 25:\ncanal=25 plot((1:nrow(PEFreq))/HZ*1000-100, PERaro[,canal]-PEFreq[,canal],type=\u0026quot;l\u0026quot;,xlab=\u0026quot;Tempo(ms)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;,ylim=c(-8,4)) abline(v=0,lty=3) Resumo: Na questão de potenciais evocados, trabalhamos com as médias dos sinais. Basicamente visam dois objetivos:\n Sinal de EEG é extremamente ruidoso (artefatos musculares e do ambiente). Aumentar o SNR - signal-to-noise ratio (ou relação sinal-ruído em português)\n Extrair “componente”\u0026quot; comum entre os trials\n   "
},
{
	"uri": "/aulas/4_epocas/",
	"title": "Identificação de épocas",
	"tags": [],
	"description": "",
	"content": "O número de tentativas necessárias para obter um ERP depende de vários fatores, sendo o mais importante a “relação sinal-ruído” (Signal to Noise Ratio), ou seja, o tamanho relativo do sinal (o ERP) em relação ao tamanho do ruído. Em experimentos cognitivos, 30 a 50 apresentações de estímulo são normalmente necessárias para se obter um ERP médio bom e limpo.\nIdentificação de épocas (períodos dos estímulos) num experimento. O número de épocas (trials) aumenta a SNR.\n#Leitura de dados sinais=read.table(\u0026quot;OlhosFechados.txt\u0026quot;,header=FALSE) #Nome dos canais nomescanais=scan(\u0026quot;NOMEScanais.txt\u0026quot;,what=\u0026quot;string\u0026quot;) dim(sinais) ## [1] 45315 32 nomescanais ## [1] \u0026quot;Fp1\u0026quot; \u0026quot;Fp2\u0026quot; \u0026quot;F7\u0026quot; \u0026quot;F3\u0026quot; \u0026quot;Fz\u0026quot; \u0026quot;F4\u0026quot; \u0026quot;F8\u0026quot; \u0026quot;FC5\u0026quot; \u0026quot;FC1\u0026quot; \u0026quot;FC2\u0026quot; ## [11] \u0026quot;FC6\u0026quot; \u0026quot;T7\u0026quot; \u0026quot;C3\u0026quot; \u0026quot;Cz\u0026quot; \u0026quot;C4\u0026quot; \u0026quot;T8\u0026quot; \u0026quot;TP9\u0026quot; \u0026quot;CP5\u0026quot; \u0026quot;CP1\u0026quot; \u0026quot;CP2\u0026quot; ## [21] \u0026quot;CP6\u0026quot; \u0026quot;TP10\u0026quot; \u0026quot;P7\u0026quot; \u0026quot;P3\u0026quot; \u0026quot;Pz\u0026quot; \u0026quot;P4\u0026quot; \u0026quot;P8\u0026quot; \u0026quot;PO9\u0026quot; \u0026quot;O1\u0026quot; \u0026quot;Oz\u0026quot; ## [31] \u0026quot;O2\u0026quot; \u0026quot;PO10\u0026quot; Para saber o período de aquisição dos dados, basta dividir o número de linhas por 32:\n# Considerando taxa de amostragem e convertendo pra minutos: 45315/(200*60) ## [1] 3.77625 # Conteúdo do vetor do trigger: ts.plot(sinais) Para definição das épocas dos eventos (intervalos dos trials), precisamos identificar as amplitudes dos intervalos e assinalar na matriz os intervalos de tempo entre os eventos:\nComandos importantes:\n round(): arredondamento matemático\n floor(): arredondamento para baixo\n ceiling(): arredondamento para cima\n  # Análisando uma época de 5s numa taxa de amostragem de 200hz: # Considerando o tamanho de 5s, seria: # TAM = seg * HZ = 5 * 200 HZ = 200 # taxa de amostragem considerada: TamSegundos=5 # Numero de segundos do trial: TAM = TamSegundos*HZ Nepocas = floor(nrow(sinais)/TAM) Ncanais = ncol(sinais) # Inicializar a matriz com as amplitudes de cada epoca para cada canal: #Inicializar a matriz com as amplitudes de cada epoca para cada canal AMPLITUDE= matrix(0, Nepocas, Ncanais) for(canal in 1:Ncanais){ for(epoca in 1:Nepocas){ #Casela de inicio da epoca INICIO=(epoca-1)*TAM+1 #Casela de fim da epoca FIM=epoca*TAM #Calculo de amplitude AMPLITUDE[epoca,canal]=max(sinais[INICIO:FIM,canal])- min(sinais[INICIO:FIM,canal]) }#for da epoca }#for dos canais Para analisar os dados da amplitude, podemos ver a distribuição no histograma abaixo:\n#Analisar a distribuicao das amplitudes hist(c(AMPLITUDE)) Limitando um pouco a visualização, no caso em 150:\nLIMIAR=150 #escolhido analisando o histograma Criando uma matriz de controle de qualidade de dimensão idêntica ao da matriz AMPLITUDE. O ZERO corresponde a épocas sem problemas e UM são as épocas onde a amplitude foi maior que um limiar:\nCQ=matrix(0,Nepocas,Ncanais) CQ[which(AMPLITUDE\u0026gt;LIMIAR)]=1 Para identificar os CANAIS mais problemáticos e realizar a contagem das épocas descartadas em cada canal:\ncolSums(CQ) ## [1] 8 2 4 1 1 0 0 2 0 0 0 11 6 0 1 8 10 0 0 1 1 9 4 ## [24] 0 1 3 9 10 1 3 7 3 Unindo as colunas dos canais com as épocas descartadas:\ncbind(nomescanais,colSums(CQ)) ## nomescanais ## [1,] \u0026quot;Fp1\u0026quot; \u0026quot;8\u0026quot; ## [2,] \u0026quot;Fp2\u0026quot; \u0026quot;2\u0026quot; ## [3,] \u0026quot;F7\u0026quot; \u0026quot;4\u0026quot; ## [4,] \u0026quot;F3\u0026quot; \u0026quot;1\u0026quot; ## [5,] \u0026quot;Fz\u0026quot; \u0026quot;1\u0026quot; ## [6,] \u0026quot;F4\u0026quot; \u0026quot;0\u0026quot; ## [7,] \u0026quot;F8\u0026quot; \u0026quot;0\u0026quot; ## [8,] \u0026quot;FC5\u0026quot; \u0026quot;2\u0026quot; ## [9,] \u0026quot;FC1\u0026quot; \u0026quot;0\u0026quot; ## [10,] \u0026quot;FC2\u0026quot; \u0026quot;0\u0026quot; ## [11,] \u0026quot;FC6\u0026quot; \u0026quot;0\u0026quot; ## [12,] \u0026quot;T7\u0026quot; \u0026quot;11\u0026quot; ## [13,] \u0026quot;C3\u0026quot; \u0026quot;6\u0026quot; ## [14,] \u0026quot;Cz\u0026quot; \u0026quot;0\u0026quot; ## [15,] \u0026quot;C4\u0026quot; \u0026quot;1\u0026quot; ## [16,] \u0026quot;T8\u0026quot; \u0026quot;8\u0026quot; ## [17,] \u0026quot;TP9\u0026quot; \u0026quot;10\u0026quot; ## [18,] \u0026quot;CP5\u0026quot; \u0026quot;0\u0026quot; ## [19,] \u0026quot;CP1\u0026quot; \u0026quot;0\u0026quot; ## [20,] \u0026quot;CP2\u0026quot; \u0026quot;1\u0026quot; ## [21,] \u0026quot;CP6\u0026quot; \u0026quot;1\u0026quot; ## [22,] \u0026quot;TP10\u0026quot; \u0026quot;9\u0026quot; ## [23,] \u0026quot;P7\u0026quot; \u0026quot;4\u0026quot; ## [24,] \u0026quot;P3\u0026quot; \u0026quot;0\u0026quot; ## [25,] \u0026quot;Pz\u0026quot; \u0026quot;1\u0026quot; ## [26,] \u0026quot;P4\u0026quot; \u0026quot;3\u0026quot; ## [27,] \u0026quot;P8\u0026quot; \u0026quot;9\u0026quot; ## [28,] \u0026quot;PO9\u0026quot; \u0026quot;10\u0026quot; ## [29,] \u0026quot;O1\u0026quot; \u0026quot;1\u0026quot; ## [30,] \u0026quot;Oz\u0026quot; \u0026quot;3\u0026quot; ## [31,] \u0026quot;O2\u0026quot; \u0026quot;7\u0026quot; ## [32,] \u0026quot;PO10\u0026quot; \u0026quot;3\u0026quot; Agora identificando as ÉPOCAS mais problemáticas e verificar as épocas com problemas em mais de um canal:\nrowSums(CQ) ## [1] 11 7 9 5 2 4 2 2 2 4 15 15 4 3 2 1 0 0 0 0 0 0 0 ## [24] 0 0 1 3 0 3 1 1 0 2 1 2 0 1 2 0 0 1 0 0 0 0 Olhando um canal específico (ex: Fp1) na época 11:\nepoca=11 INICIO=(epoca-1)*TAM+1 FIM=epoca*TAM ts.plot(sinais[INICIO:FIM,1]) "
},
{
	"uri": "/aulas/5_transformadas/",
	"title": "Transformadas de Fourier",
	"tags": [],
	"description": "",
	"content": "O conteúdo dessa aula auxilia no entendimento da amostragem no domínio da frequência e reconstrução de sinais de tempo discreto. No quesito de análise de dados com EEG, os processos de transformação de amostras do domínio do tempo para o domínio da frequência. Estas incluem tanto a análise direta do espectro de frquência, bem como convoluções. Existem variações relacionadas com a transformada, dependendo do tipo de cada função.\nA análise espectral decompõe o sinal de EEG em suas componentes fundamentais (harmônicos) que geram frequências conhecidas que podem ser distinguidas entre si.\nT = 100 lambda1 = 30 lambda2 = 50 lambda3 = 110 x= sin(2*pi*lambda1*(1:T)/T) +0.5*sin(2*pi*lambda2*(1:T)/T) +0.25*sin(2*pi*lambda3*(1:T)/T) ## [1] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -5.514005e-16 ## [6] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 1.102801e-15 ## [11] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 1.221552e-16 ## [16] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 2.205602e-15 ## [21] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -9.806459e-16 ## [26] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 -2.443104e-16 ## [31] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 1.469267e-15 ## [36] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 4.411204e-15 ## [41] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -3.186248e-15 ## [46] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 1.961292e-15 ## [51] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -7.363355e-16 ## [56] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 -4.886208e-16 ## [61] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 1.713577e-15 ## [66] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 -2.938533e-15 ## [71] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -1.004737e-14 ## [76] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 8.822409e-15 ## [81] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -7.597453e-15 ## [86] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 6.372496e-15 ## [91] 1.469463e-01 2.377641e-01 2.377641e-01 1.469463e-01 -5.147540e-15 ## [96] -1.469463e-01 -2.377641e-01 -2.377641e-01 -1.469463e-01 3.922584e-15 ts.plot(x) Ruído-branco Gaussiano. FFT: Fast Fourier Transform Idêntico à definição se T for potência de 2 (ou aproximação de).\nhist(rnorm(T)) x = x+rnorm(T) ts.plot(x) O R já calcula o estimador do espectro (periodograma). O conceito é definido como “estimado” pois ele faz uma estimativa e não uma média de todos os dados gerados. (MELHORAR EXPLICAÇÃO)\n(COLOCAR AS FAIXAS DE FREQUÊNCIA DAS BANDAS delta \u0026lt;4hz, theta 4-7hz, alfa 8-12hz, beta 13-30hz, gama \u0026gt; 30hz… )\nESPECTRO = spectrum(x) # O eixo x ficaria em plot(ESPECTRO$freq, ESPECTRO$spec, type = \u0026quot;l\u0026quot;) Implementando com o banco de dados Realizando a leitura dos dados:\n#leitura dos sinais sinais=read.table(\u0026quot;OlhosFechados.txt\u0026quot;,header=FALSE) #leitura do nome dos canais nomescanais=scan(\u0026quot;NOMEScanais.txt\u0026quot;,what=\u0026quot;string\u0026quot;) dim(sinais) ## [1] 45315 32 nomescanais  ## [1] \u0026quot;Fp1\u0026quot; \u0026quot;Fp2\u0026quot; \u0026quot;F7\u0026quot; \u0026quot;F3\u0026quot; \u0026quot;Fz\u0026quot; \u0026quot;F4\u0026quot; \u0026quot;F8\u0026quot; \u0026quot;FC5\u0026quot; \u0026quot;FC1\u0026quot; \u0026quot;FC2\u0026quot; ## [11] \u0026quot;FC6\u0026quot; \u0026quot;T7\u0026quot; \u0026quot;C3\u0026quot; \u0026quot;Cz\u0026quot; \u0026quot;C4\u0026quot; \u0026quot;T8\u0026quot; \u0026quot;TP9\u0026quot; \u0026quot;CP5\u0026quot; \u0026quot;CP1\u0026quot; \u0026quot;CP2\u0026quot; ## [21] \u0026quot;CP6\u0026quot; \u0026quot;TP10\u0026quot; \u0026quot;P7\u0026quot; \u0026quot;P3\u0026quot; \u0026quot;Pz\u0026quot; \u0026quot;P4\u0026quot; \u0026quot;P8\u0026quot; \u0026quot;PO9\u0026quot; \u0026quot;O1\u0026quot; \u0026quot;Oz\u0026quot; ## [31] \u0026quot;O2\u0026quot; \u0026quot;PO10\u0026quot; Parametrizando as variáveis iniciais:\n#Taxa de amostragem HZ=250 #Tamanho da epoca (janela) em segundos TAMsegundos=5 #Tamanho da epoca (janela) em caselas do vetor de sinais TAM=TAMsegundos*HZ #Numero de epocas Nepocas=floor(nrow(sinais)/TAM) #Numero de canais Ncanais=ncol(sinais) Criando matriz Espectro para armazenar a média dos periodogramas entre todas as épocas para cada canal. As linhas representam diferentes frequências As colunas representam os canais\nESPECTRO=matrix(0,TAM/2,Ncanais) #Calcular para cada canal # Escondi a saída de todos os espectros porque tem muitos canais e épocas na saída for(canal in 1:Ncanais){ y=0 #Calcula a media entre épocas for(epoca in 1:Nepocas){ #Descobrir caselas de inicio e fim de cada epoca INICIO=TAM*(epoca-1)+1 FIM=epoca*TAM y=y+spectrum(sinais[INICIO:FIM,canal])$spec }#for da epoca ESPECTRO[,canal]=y/Nepocas }#for do canal  Grafico do espectro no canal O1, coluna 29. plot((HZ/2)*(1:nrow(ESPECTRO))/nrow(ESPECTRO), ESPECTRO[, 29], type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Frequencia (Hz)\u0026quot;, ylab=\u0026quot;Potencia (uV^2)\u0026quot;) Ajustando o zoom para conseguir visualizar a informação melhor:\n# O professor colocou 10:200 mas voce nao quer ver 190 gráficos aqui IX=10:200 plot((HZ/2)*IX/nrow(ESPECTRO), ESPECTRO[IX,29], type=\u0026quot;l\u0026quot;,xlab=\u0026quot;Frequencia (Hz)\u0026quot;,ylab=\u0026quot;Potencia (uV^2)\u0026quot;) #Armazenar o espectro estimado médio de olhos fechados ESPECTROof=ESPECTRO Para armazenar o espectro estimado médio de olhos abertos e colocar os dois no mesmo gráfico:\nESPECTROoa=ESPECTRO ##### COLOCAR OS 2 espectros médios no mesmo grafico #ZOOM no grafico IX=10:200 plot((HZ/2)*IX/nrow(ESPECTROof), ESPECTROof[IX,29], type=\u0026quot;l\u0026quot;,xlab=\u0026quot;Frequencia (Hz)\u0026quot;,ylab=\u0026quot;Potencia (uV^2)\u0026quot;) legend(\u0026quot;topright\u0026quot;,c(\u0026quot;Olhos Fechados\u0026quot;,\u0026quot;Olhos Abertos\u0026quot;),lty=c(1,1), col=c(1,2)) No gráfico podemos o espectro para cada frequência (analisar o espectro para cada faixa) e não a evolução em si (pois não está no tempo).\n "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "Processamento de sinais neurais",
	"tags": [],
	"description": "",
	"content": "Essa página contém as notas da aula referentes ao curso de Processamento de Sinais Neurais dos cursos Bacharelado/Pós Graduação em Neurociência da UFABC.\nUtilize o menu ao lado para encontrar o conteúdo do curso.\nOs tópicos das aulas se encontram dentro do menu \u0026ldquo;Conteúdo\u0026rdquo; ao lado. As notas foram criadas em R Markdown, utilizando o R Studio.\nQuaisquer correções, erros e sugestões de acréscimos, favor entrar em contato com amanda.yumi at ufabc.edu.br\n"
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]