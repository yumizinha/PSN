[
{
	"uri": "/en/aulas/",
	"title": "Conteúdo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/aulas/aula_1_intror/",
	"title": "Introdução ao R",
	"tags": [],
	"description": "",
	"content": "Introdução ao R - comandos O R é um software importante para análise de dados estatísticos. Apesar de não ter uma interface gráfica , a usabilidade é melhor para personificação das análises e permite mais opções para visualização e análise de dados.\nVetor e matrizes no R: Para armazenar um valor a uma variável, simplesmente usamos:\nx = 3.7 O vetor é uma estrutura de dados básica do R, que permite armazenar um conjunto de valores numéricos ou de caractere sob um mesmo tipo.\nx = c(1, 2, 3, 4) x ## [1] 1 2 3 4 Para criar um vetor com repetidos valores, por exemplo uma repetição de zeros, utiliza-se:\nx = array(0, 100) x ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [36] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [71] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Para criar uma matriz, utiliza-se uma estrutura similar.\nx = matrix(1, 2, 2) x ## [,1] [,2] ## [1,] 1 1 ## [2,] 1 1 Atribuindo algum valor (1000) ao intervalo, no caso primeira linha:\nx[1,]=1000 # Saída da matriz inteira com 1000 na primeira linha e 1 no resto: x ## [,1] [,2] ## [1,] 1000 1000 ## [2,] 1 1 Caso queira exibir uma única linha ou coluna, basta digitar o comando com a linha ou coluna desejada:\n# Coluna x[,2] ## [1] 1000 1 #Linha: x[2,] ## [1] 1 1  Listas no R: Listas são objetos que podem armazenar objetos de dados de tipos diferentes. É possível incluir data.frames, arrays, matrizes, vetores, fatores e mesmo listas em uma lista.\nlist=list() list$nome = \u0026quot;joao\u0026quot; list$idade = 40 list$vetor=c(1,2,3) list$nome ## [1] \u0026quot;joao\u0026quot; # Saída: list ## $nome ## [1] \u0026quot;joao\u0026quot; ## ## $idade ## [1] 40 ## ## $vetor ## [1] 1 2 3  Loops R: Para realizar uma repetição com variável de controle, o comando for() incrementa um índice dentro de uma sequência de valores.\nfor(i in 1:10){ print (i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Para reaizar uma repetição pré-testada, o teste para sair do laço de repetição é realizado antes de entrar no laço, e para isso utilizamos a função while():\ni=1 while(i\u0026lt;=10){ print (i) i=i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Ou outro exemplo:\ni=1 while(i\u0026lt;=10){ print (i) if (i\u0026lt;=5) { print(\u0026quot;menor ou igual a 5\u0026quot;) } else{ print(\u0026quot;maior que 5\u0026quot;) } i=i+1 } ## [1] 1 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 2 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 3 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 4 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 5 ## [1] \u0026quot;menor ou igual a 5\u0026quot; ## [1] 6 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 7 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 8 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 9 ## [1] \u0026quot;maior que 5\u0026quot; ## [1] 10 ## [1] \u0026quot;maior que 5\u0026quot; No R, o índice i for imutável, recomenda-se utilizar o “for” como opção de repetição.\n Outras funções úteis no R: A Estatística Descritiva está diretamente ligada à organização e descrição dos dados. É utilizada para sumarizar como as observações se distribuem e onde estão posicionadas (ex.: medidas de tendência central e dispersão) e como se apresentam em termos de associação. Os conceitos e métodos descritivos são ponto de partida da análise exploratória de dados, passo fundamental para análises estatísticas mais avançadas.\nConsiderando a matriz criada x,\nx ## [,1] [,2] ## [1,] 1000 1000 ## [2,] 1 1 temos as seguintes funções para estatística descritiva:\n# Média: mean(x) ## [1] 500.5 # Desvio padrão sd(x) ## [1] 576.7729 # Distribuição normal: rnorm(x) ## [1] -0.2941549 -0.5695707 -1.1018875 1.4181125 # Boxplot: boxplot(x)   Leitura de dados de ECG A primeira vista, pode parecer contraintuitivo que num curso de Processamento de Sinais Neurais contenha análise de dados de Eletrocardiograma (ECG). Dentre os parâmetros que podem ser aferidos a partir do ECG é a frequência cardíaca (número de batimentos do coração que acontecem a cada minuto - bpm). A freqüência cardíaca é capaz de indicar uma ativação geral do sistema nervoso autônomo, responsável por controlar nossas reações corporais involuntárias. Ao expor uma pessoa em situações de maior demanda energética, o coração bate mais forte e mais rápido.\nO uso do ECG fornece dados informativos acerca dos processos psicofisiológicos em diversas situações, sendo altamente aplicável em estudos que investigam as respostas comportamentais como por exemplo de consumidores ou outros entrevistados.\nLeitura de dados de ECG: Na aula o professor disponibilizou dados de um arquivo em que ele coletou dados de ECG de si mesmo (a partir de um arduino). O arquivo contém uma única coluna que é o valor em mV coletado com o instrumento:\ndados = read.table(\u0026quot;ecg.txt\u0026quot;, header = FALSE) Para visualizar os dados da forma de série temporal, utiliza-se a função ts.plot(). Algumas versões do R Studio contém um problema para visualização dos dados, então utiliza-se a seguinte gambiarra recomendada pelo Stackoverflow:\n# Pra não dar erro \u0026quot;figure margins too large\u0026quot; no ts.plot: graphics.off() par(\u0026quot;mar\u0026quot;) ## [1] 5.1 4.1 4.1 2.1 par(mar=c(1,1,1,1)) Após implementar essas linhas, na sequência, visualizamos os dados com a função:\n# Plotando gráfico de linha - ECG ts.plot(dados) Um histograma pode ajudar a melhorar a visualização da amplitude do sinal:\nhist(dados$V1) Para fins de referência, consideremos como picos de batimentos os valores com resultados acima de 685mV, então destacaríamos os maiores:\n# Para percorrer todas as casas dos dados, detectando os picos: picos=array(0, nrow(dados)) for(i in 1:960){ if(dados$V1[i]\u0026gt;685){ picos[i]=1 } } # Unindo no plot as colunas de dados e picos ts.plot(cbind(dados$V1, picos)) # Como pode ver, ficou zoado, então ajustamos a escala e adicionamos cores para que se possa visualizar os dados: # cores: col 2 = preto e 1 vermelho ts.plot(cbind(dados$V1, picos+684), col=c(2,1)) O ajuste ainda não ficou muito claro. Toda vez que encontrar um pico, os valores conseguintes referem-se ao mesmo pico, ou seja, devemos limpar os dados (retirada de picos contínuos adjacentes). Neste caso, escolhemos ignorar os picos dos 10 dados seguintes ao primeiro pico.\nNota: Para percorrer o vetor completo, basta percorrer o código até os 10 últimos (critério de parada) dados. Os demais picos seriam ignorados de qualquer forma e poderia reproduzir erro no vetor.\nDessa forma, teríamos:\nfor(i in 1:(nrow(dados)-10) ){ if(picos[i]==1){ picos[(i+1):(i+10)]=0 } } ts.plot(cbind(dados$V1,picos+684),col=c(2,1))   "
},
{
	"uri": "/en/aulas/aula_2_filtro_sinais/",
	"title": "Filtros de sinais",
	"tags": [],
	"description": "",
	"content": "Breve introdução sobre filtros: O processo de filtragem de sinais permite a caracterização dos sinais a partir de suas características. Por exemplo, ao aplicar um filtro no processo de equalização de ondas sonora, podemos verificar que as frequências mais altas representam os sons mais agudos, enquanto que as frequências mais baixas representam os sons mais graves.\nOutro exemplo é a luz branca, que é a composição de diversas ondas com diferentes frequências. Assim, ao aplicarmos um filtro podemos separar as cores individualmente, a partir da aplicação de um filtro de frequência na cor associada.\nNos casos do sinais de Eletroencefalografia (EEG), temos o ruído da rede elétrica que no Brasil é 60 Hz. Além desses existem outros artefatos como ondas de baixas frequências devido ao calor na cabeça do indivíduo. Deste modo, é extremamente importante aplicação de filtros nestes sinais para remoção de tais artefatos antes de qualquer outra análise.\nComo tirar as baixas e altas frequências pensando em janela de médias? Podemos definir um filtro passa baixa a partir da subtração do sinal original pela média aritmética dos pontos ao redor de um ponto. Como resultado resta no sinal apenas as baixas frequências. Já para um filtro passa alta, fazemos a subtração do sinal original pelo sinal resultante do filtro passa baixa. Como resultado resta no sinal apenas os sinais com alta frequência. Alguns conceitos importantes para a construção dos filtros:\n Frequência de amostragem: Corresponde ao número de observação em um intervalo de tempo. Quando se trabalha com segundo, temos essa média em Hz.  Ex: Na câmera fotográfica temo 30 frames por segundo (fps). Na ressonância magnética funcional (fMRI), temos 1 imagem a cada 2 segundos. Logo, a frequência de amostragem é 1/2 = 0.5Hz Observação: A frequência = 1/período da observação  Frequência de Nyquist: Corresponde à metade da frequência da taxa amostragem.  Note: A frequência de Nyquist vale para qualquer modalidade de técnica de neuroiumagem (fMRI,EEG,fNIRS…).   O filtro permite a passagem o sinal de parte dos dados e impede a retirada de outros. São os filtros:\n Passa-alta (High pass): Deixa passar as altas frequências (maior importância pra alta frequência e baixa importáncia para baixa frequência.\n Passa-baixa (Low pass): Deixa passar as baixas frequências e dá pouca importância às altas frequências.\n Passa-banda (band pass): O sinal resultante após o filtro possui apenas a banda de frequência utilizada no filtro.\n  Implementação de filtros em R e carregando dados: No R faremos primeiro o desenho do filtro: ou seja definir qual o tipo de frequências vamos passar, para isso usaremos o comando “butter” no pacote signal.\nCaso não tenha o pacote, utilize os comandos:\nInstalando pacote de sinais no R: * install.packages(“signal”)\ne no código chamar a blbioteca\nrequire(signal) O exercício da aula mostra a leitura de um banco de dados de sinais de EEG.\nPara isso, será necessário realizar a leitura dos dados:\nsinais=read.table(\u0026quot;oddball250hz.txt\u0026quot;,header=FALSE) ver também a verificação dos dados:\ndim(sinais) ## [1] 45461 33 Olhan do o arquivo, ele é composto por 45461 linhas e 33 colunas (essas referentes aos 32 canais e uma última coluna de zeros).\nPara verificar os dados do arquivo em um plot:\n# Plot da série temporal: #gambiarra para o ts.plot funcionar no R Studio: graphics.off() par(\u0026quot;mar\u0026quot;) ## [1] 5.1 4.1 4.1 2.1 par(mar=c(1,1,1,1)) e o plot:\n# Plotando gráfico de linha ts.plot(sinais) A taxa de amostragem é a frequência em que a leitura ocorre: * HZ=1/INTERVALO, onde 1hz = 1/s\n# Suponha que o sinal foi adquirido sob uma taxa de amostragem de 250Hz: HZ= 250 Dessa forma, analisamos o sinal com base nessa amostragem, para todas as linhas, para o canal 5, com o plot do tipo l (linha):\n#Fazer gráfico com frescura: # plot(1:nrow(sinais), sinais[,5],type=\u0026quot;l\u0026quot;) # mas preciso considerar a frequência convertendo pra segundos: plot((1:nrow(sinais))/HZ, sinais[,5], type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab= \u0026quot;sinal uV\u0026quot;)  Utilizando a função do filtro (butter): Primeiramente se define qual o tipo de frequências vamos passar, para isso usaremos o comando “butter”. A função butter possui a seguinte síntaxe: * butter (n = ordem do filtro, w = cutoff, tipo = tipo de filtro) onde, + ordem do filtro = controla o decaimento da curva de ajuste do filtro, geralmente se usa 3 ou 5. + cutoff = frequências que se queira cortar (é um número de 0 a 1, neste caso é preciso fazer uma regra de 3; 0 = 1 e 1= frequências de Nyquist) + type = tipo de filtro (low/passa-baixa, high/passa-alta ou band-pass/passa banda)\nAplicando passa-baixa em 30Hz:\nFILTRO = butter(n=5, W =30/(HZ/2), type = \u0026quot;low\u0026quot;) # Gráfico do desenho do filtro: freqz(FILTRO) Após ter o filtro desenhado, aplica-lo sobre os dados do canal. Ao aplicar o filtro de forma direta teríamos ainda um problema:\nfiltrado_teste = filter(FILTRO, sinais[,5]) # bug de início do sinal, com valor muito alto  Para isso teria que tirar a média do sinal para ficar média 0:\ny = sinais[,5] - mean(sinais[,5]) #e novamente: #Aplicar o filtro no sinal: filtrado = filter(FILTRO, y) #Fazer o grafico com os 2 sinais plot((1:nrow(sinais))/HZ,y,type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) #Acrescentar linha com o sinal filtrado lines((1:nrow(sinais))/HZ, filtrado_teste, col=2) e sem ser no teste:\n#Acrescentar linha com o sinal filtrado plot((1:nrow(sinais))/HZ,y,type=\u0026quot;l\u0026quot;, xlab=\u0026quot;Tempo(s)\u0026quot;, ylab=\u0026quot;sinal(uV)\u0026quot;) lines((1:nrow(sinais))/HZ, filtrado, col=2)   "
},
{
	"uri": "/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for make Open Source Software a better place !\n.ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @matcornic 143 commits   @lierdakil 16 commits   @gwleclerc 13 commits   @mdavids 10 commits   @Xipas 5 commits   @mreithub 3 commits   @matalo33 3 commits   @denisvm 2 commits   @gpospelov 2 commits   @wikijm 2 commits   @lfalin 2 commits   @alexvargasbenamburg 1 commits   @afs2015 1 commits   @arifpedia 1 commits   @MrMoio 1 commits   @giuliov 1 commits   @haitch 1 commits   @RealOrangeOne 1 commits   @tanzaho 1 commits   @JohnBlood 1 commits   @kamilchm 1 commits   @sykesm 1 commits   @ripienaar 1 commits   @EnigmaCurry 1 commits   @tedyoung 1 commits   @Thiht 1 commits   @fossabot 1 commits   @kamar535 1 commits   @nonumeros 1 commits   @pgorod 1 commits   @proelbtn 1 commits   And a special thanks to @vjeantet for his work on docdock, a fork of hugo-theme-learn. v2.0.0 of this theme is inspired by his work.\nPackages and libraries  mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; horsey - Progressive and customizable autocomplete component clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support  Tooling  Netlify - Continuous deployement and hosting of this documentation Hugo  "
},
{
	"uri": "/en/",
	"title": "Learn Theme for Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": " TAT by OVH "
},
{
	"uri": "/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]