---
title: "Experimentos em fMRI e Mapas de ativação"
author: "Amanda Yumi"
date: "24 de outubro de 2018"
output: html_document
weight: 100
---

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Gambi pra funcionar o ts.plot:
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
```

COLOCAR TEXTO SOBRE DESENHO EXPERIMENTAL, BLOCK DESIGN
Maior erro dos novatos: acreditar que com um estímulo só e comparar repouso com o estímulo. É necessário ter uma amostra representativa para conseguir garantir os dados para comparação.

Para análise, precisarei:

1. Dados
2. Especificar a HRF - hemodynamic response function
3. Desenho experimental

Analisar o sinal BOLD nos n estímulos.
No desenho experimental, tenho as condições do meu experimento, convoluído pela HRF. Forma de unificar condições experimentais com a forma hemodinâmica.

Convolução:

$$
\begin{align}
X[t] = \sum_{l=0}^{k} HRF[k] \hspace{1mm}* C[t-k] && \text{(sendo C a condição)}
\end{align}
$$

Função de resposta hemodinâmica canônica:

```{r, cache = TRUE}
glover=function(HZ){
	a1=6
	a2=12
	b1=0.9
	b2=0.9
	d1=5.4
	d2=10.8
	c=0.35
	x=seq(0, 30, 1/HZ) # HZ is the Sampling Rate (Heartz)
	glover1=((x/d1)^a1)*exp((-x+d1)/b1)
	glover2=((x/d2)^a2)*exp((-x+d2)/b2)
	G=glover1-c*glover2
	return(G)
}
```

Determinando HRF: Função de resposta hemodinâmica e exemplo de event related:

```{r}
HRF = glover(0.5)
```

Exemplo de event-related:

```{r, cache = TRUE}
CONDICAO=array(0, 90)
CONDICAO[30] = 1
CONDICAO[60] = 1
ts.plot(CONDICAO)

# Convolucao do vetor condicao pela HRF
# ATENCAO: NAO LER o pacote signal, pois a função
# que faz a convolução tem o mesmo nome da que faz a
# filtragem em frequência
X=filter(CONDICAO,HRF,sides=1,method="convolution")
ts.plot(cbind(CONDICAO,X),col=c(1,2))
```

Exemplo de Desenho block-design:

```{r, cache = TRUE}
CONDICAO=array(0, 90)
CONDICAO[20:40] = 1
CONDICAO[60:80] = 1
X=filter(CONDICAO, HRF, sides=1, method="convolution")
ts.plot(cbind(CONDICAO, X), col=c(1, 2))

```

No GLM, faremos uma regressão linear múltipla onde o Y é o sinal BOLD, usando a HRF convoluída. No fundo, quero saber se o sinal se comporta conforme a ativação do voxel (se o voxel é ativado por um determinado estímulo).

Para regressão múltipla, faremos um ajuste de nível ($\alpha$) e de escala ($\beta$)

$$
\begin{align}
BOLD_{x,y,z}[t] = \alpha + \beta . X_t + \epsilon_t && \text{(sendo X_t a condição da convolução)}
\end{align}
$$

neste caso, supondo:
$\epsilon_t$ com média zero e variância constante (homocedasticidade)
Erros $\epsilon_t$ são independentes

Para comparação, faremos um teste de hipóteses para verificar.

```{r, cache = TRUE}
require(AnalyzeFMRI)

#Leitura de dados de fMRI
volume=f.read.volume("Stroop.nii")

#Leitura das condicoes (desenho experimental)
congruente=scan("congruent.txt")
incongruente=scan("incongruent.txt")
```

```{r, cache = TRUE}
glover=function(HZ){
	a1=6
	a2=12
	b1=0.9
	b2=0.9
	d1=5.4
	d2=10.8
	c=0.35
	x=seq(0, 30, 1/HZ) # HZ is the Sampling Rate (Heartz)
	glover1=((x/d1)^a1)*exp((-x+d1)/b1)
	glover2=((x/d2)^a2)*exp((-x+d2)/b2)
	G=glover1-c*glover2
	return(G)
}

#HRF- Funcao de resposta hemodinamica
HRF=glover(0.5)

#Convolucao da condicao congruente pela HRF
X=filter(congruente, HRF, sides=1, method="convolution")

#Convolucao da condicao incongruente pela HRF
Z=filter(incongruente, HRF, sides=1, method="convolution")

ts.plot(cbind(congruente, incongruente), col=c(1,2))
ts.plot(cbind(X, Z), col=c(1, 2))

```

Realizando o ajuste do modelo linear geral:

```{r, cache = TRUE}
# Verificando a dimensão do volume para identificar como serão os mapas:
dim(volume)
```

Analisando pelo t-valor, estatística t (verificar ativa ou não e se é estatisticamente diferente de zero ou não).

Estatística T do beta correspondente a condição congruente é igual ao do modelo.

##Verificando a Tarefa Stroop com imagem processada.

Realizando a leitura dos dados e separando entre congruente e incongruente:
```{r, cache=TRUE}

# Imagem esta preprocessada
# SPM (UCL) e FSL (Oxford)


require(AnalyzeFMRI)

#Leitura de dados de fMRI
volume=f.read.volume("Stroop.nii")

#Leitura das condicoes (desenho experimental)
congruente=scan("congruent.txt")
incongruente=scan("incongruent.txt")

glover=function(HZ){
	a1=6
	a2=12
	b1=0.9
	b2=0.9
	d1=5.4
	d2=10.8
	c=0.35
	x=seq(0, 30, 1/HZ) # HZ is the Sampling Rate (Heartz)
	glover1=((x/d1)^a1)*exp((-x+d1)/b1)
	glover2=((x/d2)^a2)*exp((-x+d2)/b2)
	G=glover1-c*glover2
	return(G)
}
```

Calculando o HRF:

```{r, cache = TRUE}
#HRF- Funcao de resposta hemodinamica
HRF=glover(0.5)

#Convolucao da condicao congruente pela HRF
X=filter(congruente,HRF,sides=1,method="convolution")

#Convolucao da condicao incongruente pela HRF
Z=filter(incongruente,HRF,sides=1,method="convolution")

ts.plot(cbind(congruente,incongruente),col=c(1,2))
ts.plot(cbind(X,Z),col=c(1,2))

```

Fazendo os Mapas de estatisticas T

```{r, cache = TRUE}
mapaTcongruente=array(0,c(45,54,45,1))
mapaTincongruente=array(0,c(45,54,45,1))

for(xi in 1:45){
  for(yi in 1:54){
    for(zi in 1:45){
        #pega somente os voxels intracranianos
       if(volume[xi,yi,zi,1]!=0){
         #Ajuste do modelo linear geral
         modelo=lm(volume[xi,yi,zi,]~X+Z)

         #Estatistica T do beta correspondente a condicao congruente
         mapaTcongruente[xi,yi,zi,1]=summary(modelo)$coef[2,3]

         #Estatistica T do beta correspondente a condicao incongruente
         mapaTincongruente[xi,yi,zi,1]=summary(modelo)$coef[3,3]
       }#fecha if
}}}#fecha for do xi,yi,zi

```

Agora, armazenando os mapas em arquivos no formato Analyze (um IMG e um HDR):

```{r, cache = TRUE}
f.write.analyze(mapaTcongruente, "MapaCongruente", 
                pixdim = c(4, 4, 4),
                originator = c(23.5, 32.5, 19, 1, 1))
f.write.analyze(mapaTincongruente, "MapaIncongruente", 
                pixdim = c(4, 4, 4),
                originator = c(23.5, 32.5, 19, 1, 1))
```

A estatística T me diz se os valores de $\beta_1$ são maiores ou não que zero. Usamos um p de 0,1% para evitar os ruídos da suavização, que geram falsos positivos (t = 3.03).

